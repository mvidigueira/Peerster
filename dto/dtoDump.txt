//STATUS

type MsgMap struct {
	rumors map[string][]RumorMessage
	mux    sync.Mutex
}

type StatusMap struct {
	m       map[string]uint32
	sending bool
	mux     sync.Mutex
}

func (mm *MsgMap) Lock() {
	mm.mux.Lock()
}

func (mm *MsgMap) Unlock() {
	mm.mux.Unlock()
}

func NewStatusMap() StatusMap {
	return StatusMap{m: make(map[string]uint32)}
}

func (wm *MsgMap) AddRumor(packet *GossipPacket) {
	rumor := packet.Rumor
	if rumor != nil {
		wm.mux.Lock()
		v, ok := wm.rumors[rumor.Origin]
		if !ok {
			v = make([]RumorMessage, 0)
			wm.rumors[rumor.Origin] = v
		}
		if rumor.ID == uint32(len(v)) { //only add next message
			wm.rumors[rumor.Origin] = append(v, *rumor)
		}
		wm.mux.Unlock()
	}
}

func (wm *MsgMap) GetRumor(name string, msgId uint32) *RumorMessage {
	wm.mux.Lock()
	//TODO: safety on first access
	var rumor RumorMessage
	if msgId < uint32(len(wm.rumors[name])) {
		rumor = wm.rumors[name][msgId-1]
	}
	wm.mux.Unlock()
	return &rumor
}

func (smOld *StatusMap) GetOneOutdated(smNew *StatusMap, stopSendIfNotOutdated bool) (outdated PeerStatus, inSync bool) {
	smNew.mux.Lock()
	smOld.mux.Lock()
	for kn, vn := range smNew.m {
		vo, ok := smOld.m[kn]
		if !ok || vn > vo {
			outdated = PeerStatus{Identifier: kn, NextID: vo}
			smOld.mux.Unlock()
			smNew.mux.Unlock()
			return
		}
	}
	inSync = true
	if stopSendIfNotOutdated {
		smOld.sending = false
	}
	smOld.mux.Unlock()
	smNew.mux.Unlock()
	return
}

func (smOld *StatusMap) GetAllOutdated(smNew *StatusMap, stopSendIfNotOutdated bool) ([]PeerStatus, int) {
	outdated := make([]PeerStatus, 0)
	smNew.mux.Lock()
	smOld.mux.Lock()
	for kn, vn := range smNew.m {
		vo, ok := smOld.m[kn]
		if !ok || vn > vo {
			outdated = append(outdated, PeerStatus{Identifier: kn, NextID: vo})
		}
	}
	if len(outdated) == 0 && stopSendIfNotOutdated {
		smOld.sending = false
	}
	smOld.mux.Unlock()
	smNew.mux.Unlock()
	return outdated, len(outdated)
}

func (wm *MsgMap) ToStatusPacket() *StatusPacket {
	wm.mux.Lock()
	statusList := make([]PeerStatus, len(wm.rumors))
	i := 0
	for k, v := range wm.rumors {
		statusList[i] = PeerStatus{Identifier: k, NextID: uint32(len(v) + 1)}
		i++
	}
	wm.mux.Unlock()
	return &StatusPacket{Want: statusList}
}

//lock when calling
func (wm *MsgMap) ToStatusMap() *StatusMap {

	statusMap := NewStatusMap()
	for k, v := range wm.rumors {
		statusMap.m[k] = uint32(len(v) + 1)
	}
	wm.mux.Unlock()
	return &statusMap
}

/*
func (sp *StatusPacket) ToStatusMap() *StatusMap {
	wm.mux.Lock()
	statusMap := NewStatusMap()
	for k, v := range wm.rumors {
		statusMap.m[k] = uint32(len(v) + 1)
	}
	wm.mux.Unlock()
	return &statusMap
}*/

func (sm StatusMap) UpdateStatusMap(sp *StatusPacket) (shouldSend bool) {
	sm.mux.Lock()
	modified := false
	for _, pair := range sp.Want {
		value, ok := sm.m[pair.Identifier]
		if !ok || pair.NextID > value {
			sm.m[pair.Identifier] = value
			modified = true
		}
	}
	if modified && sm.sending == false {
		sm.sending = true
		shouldSend = true
	}
	sm.mux.Unlock()
	return
}

//just for testing

func Print(wm *MsgMap) {
	fmt.Println("-- Printing Msg Map --")
	wm.mux.Lock()
	for key, value := range wm.rumors {
		fmt.Printf("Identifier: %s\n", key)
		for _, msg := range value {
			fmt.Printf("Message ID: %d, Message: %v\n", msg.ID, msg.Text)
		}
	}
	wm.mux.Unlock()
}

//just for testing

func (sp *StatusPacket) Print() {
	fmt.Println("-- Printing Status Packet --")
	for _, v := range sp.Want {
		fmt.Printf("Identifier: %s, Next ID: %d\n", v.Identifier, v.NextID)
	}
}

func (sp *StatusPacket) String() string {
	str := ""
	for _, v := range sp.Want {
		str = str + fmt.Sprintf("peer %s nextID %d ", v.Identifier, v.NextID)
	}
	return str
}
